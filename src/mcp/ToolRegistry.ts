import { z } from 'zod';
import { CompileService } from '../core/compile/CompileService';
import { OperationManager } from '../core/operations/OperationManager';
import { WorkspaceManager } from '../core/workspace/WorkspaceManager';
import { ArtifactStore } from '../core/artifacts/ArtifactStore';
import { loadConfig, resolvePolicy, isAllowedExtension } from '../core/config/Config';
import { GitClient } from '../core/git/GitClient';
import { getTextFileContents, patchTextFileContents } from '../core/text/TextTools';

export type McpContext = {
  compileService: CompileService;
  ops: OperationManager<any, any>;
  workspaces: WorkspaceManager;
  artifacts: ArtifactStore;
  getCapabilities: () => Promise<any>;
  healthCheck: () => Promise<any>;
  appConfigRoot: string;
};

export type McpTool = {
  name: string;
  description: string;
  inputSchema: any;
  handler: (input: any) => Promise<any>;
};

export async function registerMcpTools(ctx: McpContext): Promise<McpTool[]> {
  const tools: McpTool[] = [];

  const compileInput = z.object({
    projectId: z.string(),
    rootResourcePath: z.string(),
    options: z.any().optional(),
  });

  tools.push({
    name: 'overleaf.compile_latex',
    description: 'Compile LaTeX synchronously (Local provider)',
    inputSchema: compileInput,
    handler: async (input: any) => {
      const body = compileInput.parse(input);
      const cfg = await loadConfig(ctx.appConfigRoot);
      const policy = resolvePolicy(body.projectId, cfg);
      if (!isAllowedExtension(body.rootResourcePath, policy)) throw new Error('disallowed_extension');
      const out = await ctx.compileService.compileSync(body.projectId, body.rootResourcePath, body.options || {});
      return { diagnostics: out.result.diagnostics, artifacts: out.artifacts };
    },
  });

  tools.push({
    name: 'overleaf.compile_latex_async',
    description: 'Compile LaTeX asynchronously (returns operationId)',
    inputSchema: compileInput,
    handler: async (input: any) => {
      const body = compileInput.parse(input);
      const cfg = await loadConfig(ctx.appConfigRoot);
      const policy = resolvePolicy(body.projectId, cfg);
      if (!isAllowedExtension(body.rootResourcePath, policy)) throw new Error('disallowed_extension');
      const operationId = ctx.compileService.compileAsync(body.projectId, body.rootResourcePath, body.options || {}, ctx.ops);
      return { operationId };
    },
  });

  tools.push({
    name: 'overleaf.get_compile_status',
    description: 'Get status of an async compile operation',
    inputSchema: z.object({ operationId: z.string() }),
    handler: async (input: any) => ctx.ops.get(z.object({ operationId: z.string() }).parse(input).operationId),
  });

  tools.push({
    name: 'overleaf.get_compile_artifact',
    description: 'Return signed URL for an artifact generated by a compile',
    inputSchema: z.object({ path: z.string() }),
    handler: async (input: any) => {
      // Note: artifacts are referenced by signed /artifacts/:id URLs in HTTP mode.
      // For MCP, we would map IDs directly; here we return a passthrough path.
      return { path: z.object({ path: z.string() }).parse(input).path };
    },
  });

  tools.push({
    name: 'overleaf.get_text_file_contents',
    description: 'Read a text file with optional line ranges',
    inputSchema: z.object({ projectId: z.string(), filePath: z.string(), ranges: z.array(z.object({ start: z.number(), end: z.number() })).optional() }),
    handler: async (input: any) => {
      const body = z.object({ projectId: z.string(), filePath: z.string(), ranges: z.array(z.object({ start: z.number(), end: z.number() })).optional() }).parse(input);
      const ws = await ctx.workspaces.ensureWorkspace(body.projectId);
      return getTextFileContents(ws, body.filePath, body.ranges);
    },
  });

  tools.push({
    name: 'overleaf.patch_text_file_contents',
    description: 'Apply hash-validated patches to a text file',
    inputSchema: z.object({ projectId: z.string(), filePath: z.string(), baseHash: z.string(), patches: z.array(z.object({ startLine: z.number(), endLine: z.number(), expectedHash: z.string(), newText: z.string() })) }),
    handler: async (input: any) => {
      const body = z.object({ projectId: z.string(), filePath: z.string(), baseHash: z.string(), patches: z.array(z.object({ startLine: z.number(), endLine: z.number(), expectedHash: z.string(), newText: z.string() })) }).parse(input);
      const ws = await ctx.workspaces.ensureWorkspace(body.projectId);
      return patchTextFileContents(ws, body.filePath, body.baseHash, body.patches);
    },
  });

  tools.push({
    name: 'overleaf.git_start_session',
    description: 'Clone or set remote and create a session branch',
    inputSchema: z.object({ projectId: z.string(), remoteUrl: z.string(), branch: z.string().optional() }),
    handler: async (input: any) => {
      const body = z.object({ projectId: z.string(), remoteUrl: z.string(), branch: z.string().optional() }).parse(input);
      const ws = await ctx.workspaces.ensureWorkspace(body.projectId);
      const git = new GitClient(ws);
      if (!(await git.isRepo())) {
        await GitClient.clone(body.remoteUrl, ws);
      } else {
        await git.setRemote('origin', body.remoteUrl);
        await git.fetch('origin');
      }
      const sessionBranch = body.branch || `mcp-session/${Math.random().toString(36).slice(2, 10)}`;
      await git.checkoutBranch(sessionBranch);
      return { branch: sessionBranch };
    },
  });

  tools.push({
    name: 'overleaf.git_commit_patch',
    description: 'Stage and commit current workspace changes',
    inputSchema: z.object({ projectId: z.string(), message: z.string() }),
    handler: async (input: any) => {
      const body = z.object({ projectId: z.string(), message: z.string() }).parse(input);
      const ws = await ctx.workspaces.ensureWorkspace(body.projectId);
      const git = new GitClient(ws);
      await git.addAll();
      await git.commit(body.message);
      const sha = await git.headSha();
      return { commit: sha };
    },
  });

  tools.push({
    name: 'overleaf.git_pull_push',
    description: 'Pull (ff-only/rebase) and push current branch',
    inputSchema: z.object({ projectId: z.string(), mode: z.enum(['ff-only', 'rebase']).optional() }),
    handler: async (input: any) => {
      const body = z.object({ projectId: z.string(), mode: z.enum(['ff-only', 'rebase']).optional() }).parse(input);
      const ws = await ctx.workspaces.ensureWorkspace(body.projectId);
      const git = new GitClient(ws);
      if (body.mode === 'rebase') await git.pullRebase('origin'); else await git.pullFFOnly('origin');
      await git.push('origin');
      return { pushed: true };
    },
  });

  tools.push({
    name: 'overleaf.list_projects',
    description: 'List configured projects from projects.json',
    inputSchema: z.object({}),
    handler: async () => {
      const cfg = await loadConfig(ctx.appConfigRoot);
      return { projects: Object.entries(cfg.projects).map(([key, p]) => ({ key, name: p.name, projectId: p.projectId })) };
    },
  });

  tools.push({
    name: 'overleaf.status_summary',
    description: 'Project quick status',
    inputSchema: z.object({ projectId: z.string() }),
    handler: async (input: any) => {
      const body = z.object({ projectId: z.string() }).parse(input);
      const ws = await ctx.workspaces.ensureWorkspace(body.projectId);
      const {
        listFiles } = await import('../core/project/ProjectTools');
      const files = await listFiles(ws);
      const hasMainTex = files.includes('main.tex');
      const counts: Record<string, number> = { tex: 0, bib: 0, images: 0, pdf: 0, other: 0 };
      const imgExts = new Set(['.png', '.jpg', '.jpeg', '.svg', '.eps']);
      for (const f of files) {
        const ext = f.slice(f.lastIndexOf('.') >= 0 ? f.lastIndexOf('.') : f.length).toLowerCase();
        if (ext === '.tex') counts.tex++;
        else if (ext === '.bib') counts.bib++;
        else if (imgExts.has(ext)) counts.images++;
        else if (ext === '.pdf') counts.pdf++;
        else counts.other++;
      }
      const git = new GitClient(ws);
      const isRepo = await git.isRepo();
      let branch: string | undefined; let head: string | undefined;
      if (isRepo) { try { branch = await git.currentBranch(); } catch {} try { head = await git.headSha(); } catch {} }
      return { projectId: body.projectId, hasMainTex, fileCount: files.length, counts, git: { isRepo, branch, head } };
    },
  });

  tools.push({
    name: 'overleaf.get_capabilities',
    description: 'Report runtime capabilities and limits',
    inputSchema: z.object({}),
    handler: async () => ctx.getCapabilities(),
  });

  tools.push({
    name: 'overleaf.health_check',
    description: 'Report server health',
    inputSchema: z.object({}),
    handler: async () => ctx.healthCheck(),
  });

  return tools;
}
